# 符号使用汇总

> https://blog.csdn.net/weixin_43821438/article/details/111363378?spm=1001.2014.3001.5501

## 一、数据结构相关概念

### 1. list, vector

* conj/pop/peek函数，对于list添加/删除/查看首位，对于vector添加/删除/查看末位
* 显式定义时，list需要加 ’，而vector不用，如 '(1 2) [1 2]
* 都可以使用 first, second, rest, last, nth 进行取数，此外vector可以用函数 (get v 0) 或 (v 0) 按下标取数，但list不能
* 实现方式上，list是链式存储结构，vector采用Ideal Hash Tree，在查找时vector的时间复杂度显著低于list

### 2. let, def, binding

* def作用域为整个namespace，且所有线程共享，不同函数都可以访问
* let和binding的作用域都只有其定义的括号内，且只有当前线程能读取；区别在于binding在线程内存中改变了原值，而let并没有改变，原理参见 binding和let
* binging内可以使用var-set和set!，但是let内不可以
* binding只能操作已经被 (def ^:dynamic val) 定义过的数据，而le没有限制，可以操作一个新的symbol

### 3. symbol, keyword

* keyword有两种，一种是全局关键字 :key ，另一种是绑定命名空间的关键字 ::key 或 ：user/key
* symbol也分全局符号 ‘A 和绑定命名空间的符号 'hello/A，本质上加上 ’ 以阻止求值的都是符号
* symbol、keyword、String之间的转换参见张佃鹏总结

### 4. var, resolve, #’

* 三种形式都是获取变量，效果一致

```clojure
(= (var foo) (resolve 'foo) #'foo)
```

## 二、函数相关概念

### 1. import, use, require, refer

* require 用于加载命名空间，但是加载后需要输入命名空间才能引用，可以搭配关键字
    + :as 为命名空间设定别名
    + :refer 解析后，引用该命名空间的方法不再需要输入命名空间
    + :only 只引用列出的方法
* use 等效于 require+refer，即引用且解析
* import 作用于java类，等效于 use

```clojure
   (:require [metabase.driver.util :as driver.u])
(:require metabase.util
  [i18n :refer [trs tru]]
  [schema :as su] ] )
(use '[clojure.set :only [intersection]])
(import java.util.Date)
```

### 2. fn, def, defn, defn-, defmacro, defrecord

* fn 定义匿名函数，def 将函数与函数名绑定，两者相加即为 defn
* defn- 代表私有函数，匿名函数若有多个输入可使用 %1， %2， %3
* defmacro 代表宏，宏用于生成内联代码，即“代码生成器”，可以用macroexpand展开 macro示例
* defrecord 用于定义一个映射表的结构，便于后续创建实例

```clojure
   ;; 以下三个表达式等价
(defn greet [name] (str "Hello, " name))
(def greet (fn [name] (str "Hello, " name)))
(def greet (#(str "Hello, " %)))

;; 使用 defrecord 预定义Map结构
(defrecord Book [title author]) ;定义数据类型
(def b (->Book "Diary" "George")) ;创建实例
(def b (Book. "Diary" "George")) ;创建实例

;; 运用 defmacro 定义一个私有的 def-
(defmacro def- [name & decls]
  (list* `def (with-meta name (assoc (meta name) :private true)) decls))
```

## 三、计算相关概念

### 1. comp, ->, ->>, partial

* comp 对于给定的多个函数，从右往左执行，每次执行的结果作为下一个函数的参数，接收函数只允许一个参数
* -> 对于给定的多个函数，从左往右执行，每次执行的结果作为下一个函数的第一个参数，接收函数允许多个参数
* ->> 同上，但每次执行的结果作为下一个函数的最后一个参数
* partial 对于带n个参数的函数，预先指定前m个参数，后n-m个参数在调用时输入。即通过默认值减少函数需要的参数数量，可以和comp结合使用
   