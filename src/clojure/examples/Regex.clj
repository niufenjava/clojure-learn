(ns clojure.examples.Regex)
; # Clojure 正则表达式  https://www.w3cschool.cn/clojure/clojure_regular_expressions.html
; > 正则表达式是用于在文本中查找子字符串的模式。 正则表达式用于各种编程语言，在LISP类型编程语言中使用很多。
;以下是正则表达式的示例。
;//d+
;上述正则表达式用于在字符串中再次发生一个数字。 //字符用于确保字符'd'和'+'用于表示正则表达式。
;
;一般来说，正则表达式使用以下规则集。
; * 有两个特殊的位置字符用于表示一行的开始和结束：caret（∧）和美元符号（$）：
; * 正则表达式也可以包括量词。 加号（+）表示一次或多次，应用于表达式的前一个元素。 星号（*）用于表示零个或多个出现。 问号（？）表示零或一次。
; * 元字符{和}用于匹配前一个字符的特定数量的实例。
; * 在正则表达式中，句点符号（。）可以表示任何字符。 这被描述为通配符。
; * 正则表达式可以包括字符类。 一组字符可以作为简单的字符序列，包含在元字符[和]中，如[aeiou]中。 对于字母或数字范围，可以使用[a-z]或[a-mA-M]中的短划线分隔符。 字符类的补码由方括号中的前导注释表示，如[∧a-z]中所示，并表示除指定的字符以外的所有字符。
;
; ## 下列方法可用于正则表达式。
; 1. re-pattern	返回java.util.regex.Pattern的实例。 然后将其用在用于模式匹配的其它方法中。
; 2. refind	返回字符串到模式的下一个正则表达式匹配（如果有），使java.util.regex.Matcher.find()
; 3. replace replace函数用于将字符串中的子字符串替换为新的字符串值。 使用模式来搜索子字符串。
; 4. replace-first	replace函数用于将字符串中的子字符串替换为新的字符串值，但仅用于子字符串的第一次出现。 使用模式来搜索子字符串。